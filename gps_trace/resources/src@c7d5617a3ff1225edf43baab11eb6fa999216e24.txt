from typing import Dict, Any, Optional, List
from playwright.async_api import TimeoutError as PlaywrightTimeoutError
from .base import PortalEngine
from . import register_portal
import asyncio


@register_portal("gps")
class GPS(PortalEngine):
    LOGIN = "https://gpsportal.gilberted.net/"

    # --------------------------- Debug helpers ---------------------------

    async def _debug_attach_listeners(self) -> None:
        def _console_printer(msg):
            # Filter the noisy Permissions-Policy 'battery' warning
            t = getattr(msg, "type", "").lower()
            txt = getattr(msg, "text", "")
            if t == "warning" and "Permissions-Policy" in txt:
                return
            print(f"[GPS][console] {getattr(msg,'type','').upper()}: {txt}")

        self.page.on("console", _console_printer)

        # Requests / responses of interest
        def _req(r):
            u = r.url
            if "/api/rest" in u or "AuthnEngine" in u or "idauto" in u:
                print(f"[GPS][req] {r.method} {u}")
        self.page.on("request", _req)

        async def _res(r):
            u = r.url
            if "/api/rest" in u or "AuthnEngine" in u or "idauto" in u:
                try:
                    body = await r.text()
                    print(f"[GPS][res] {r.status} {u} :: {body[:200]!r}")
                except Exception:
                    print(f"[GPS][res] {r.status} {u} :: <non-text>")
        self.page.on("response", lambda r: asyncio.create_task(_res(r)))

        # Frame navigations (incl. hash changes)
        self.page.on("framenavigated", lambda f: print(f"[GPS][nav] frame navigated → {f.url}"))

        # Auto-accept native dialogs just in case
        self.page.on("dialog", lambda d: asyncio.create_task(d.accept()))

    async def _debug_dump_state(self, label: str) -> None:
        try:
            url = self.page.url
            route_hash = await self.page.evaluate("() => window.location.hash")
            h1 = (await self.page.locator("h1, .page-heading").first.text_content()) or ""
            err = (await self.page.locator(".error, .cs-error, .validation-error, [role='alert'], .toast-error, .message-error").first.text_content()) or ""
            pictos = await self.page.locator(".pictograph-list img.tile-icon").count()
            pw_visible = await self.page.locator("form#authn-login-form input[type='password']").first.is_visible()
            go_in_form = await self.page.locator("form#authn-login-form button#authn-go-button").count()
            print(
                f"[GPS][dump:{label}] url={url} hash={route_hash!r} "
                f"h1={h1.strip()!r} err={err.strip()!r} pictos={pictos} "
                f"pw_visible={pw_visible} go_btns={go_in_form}"
            )
        except Exception as e:
            print(f"[GPS][dump:{label}] failed: {e!r}")
        try:
            await self.page.screenshot(path=f"gps_{label}.png", full_page=True)
            print(f"[GPS] Screenshot → gps_{label}.png")
        except Exception:
            pass

    # --------------------------- RapidIdentity helpers ---------------------------

    async def _authn_type(self) -> Optional[str]:
        """Return current RapidIdentity authn step: 'username' | 'password' | 'pictograph' | 'totp' | etc."""
        try:
            data = await self.page.evaluate("async () => (await fetch('/api/rest/authn')).json()")
            t = (data.get("type") or "").strip().lower()
            print(f"[GPS] authn.type = {t!r}")
            return t
        except Exception as e:
            print(f"[GPS] authn.type fetch failed: {e!r}")
            return None

    async def _find_username_input(self):
        return self.page.locator(
            "#identification, "
            "input[name='username'], "
            "input[autocomplete='username'], "
            "input[aria-label*='Username' i], "
            "input[placeholder*='Username' i], "
            "input[aria-label*='Shortname' i]"
        ).first

    async def _submit_enclosing_form(self, field_locator) -> None:
        form = field_locator.locator("xpath=ancestor::form[1]")
        # Prefer requestSubmit to keep JS handlers/validators
        try:
            await form.evaluate("f => (f.requestSubmit ? f.requestSubmit() : f.submit())")
            return
        except Exception:
            pass
        submit = form.locator("button[type='submit'], input[type='submit'], #authn-go-button").first
        if await submit.count() > 0:
            try:
                await submit.click()
            except Exception:
                await submit.click(force=True)
        else:
            await form.evaluate("f => f.submit()")

    async def _solve_pictograph(self) -> bool:
        """
        Click pictograph images by alt text using self.auth_images (case-insensitive).
        Returns True when the grid disappears (usually after 3 picks).
        """
        grid = self.page.locator(".pictograph-list")
        tile = grid.locator("img.tile-icon")

        # Wait up to ~10s for grid; if not present, nothing to solve
        try:
            await tile.first.wait_for(state="visible", timeout=10_000)
        except Exception:
            return False

        if not getattr(self, "auth_images", None):
            print("[GPS] auth_images is empty; cannot solve pictograph.")
            return False

        desired: List[str] = [str(a).strip().lower() for a in self.auth_images]
        print(f"[GPS] Pictographs visible. Target sequence: {desired}")

        for pick in range(1, 6):  # cap to avoid infinite loop
            alts: List[str] = await tile.evaluate_all("imgs => imgs.map(i => (i.alt || '').toLowerCase().trim())")
            match = next((a for a in desired if a in alts), None)
            if not match:
                await self.page.screenshot(path=f"gps_pictograph_no_match_{pick}.png", full_page=True)
                print(f"[GPS] No matching pictograph on pick {pick}. Options={alts}")
                return False

            print(f"[GPS] Pick {pick}: clicking '{match}'")
            # Click the exact matching node via JS (CSS can't lowercase)
            await self.page.locator(".pictograph-list img.tile-icon").evaluate_all(
                "(imgs, target) => imgs.find(i => (i.alt || '').toLowerCase().trim() == target)?.click()",
                match
            )

            # Brief pause; exit when grid/tiles disappear
            try:
                await self.page.wait_for_timeout(250)
                if await grid.count() == 0:
                    print("[GPS] Pictograph step complete (container removed).")
                    return True
                if not await tile.first.is_visible(timeout=2_000):
                    print("[GPS] Pictograph step complete (tiles hidden).")
                    return True
            except Exception:
                print("[GPS] Pictograph grid disappeared.")
                return True

        await self.page.screenshot(path="gps_pictograph_stuck.png", full_page=True)
        print("[GPS] Pictograph step did not complete within 5 picks.")
        return False

    # --------------------------- Contract stub ---------------------------

    async def fetch_grades(self) -> Dict[str, Any]:
        # Barebones placeholder to satisfy the abstract method
        return {"parsed_grades": {}}

    # --------------------------- Main login ---------------------------

    async def login(self, first_name: Optional[str] = None) -> None:
        await self.page.context.tracing.start(screenshots=True, snapshots=True, sources=True)
        await self._debug_attach_listeners()
        try:
            print("[GPS] Navigating to LOGIN…")
            await self.page.goto(self.LOGIN, wait_until="domcontentloaded")

            # If needed, reset the flow
            start_over_btn = self.page.locator("#authn-startover-button")
            if await start_over_btn.count() > 0 and await start_over_btn.is_visible():
                await start_over_btn.click()
                ok_btn = self.page.locator("button:has-text('OK')")
                if await ok_btn.count() > 0:
                    await ok_btn.click()
                print("[GPS] Reset via Start Over → OK.")

            # ---------- USERNAME STEP ----------
            step = await self._authn_type()
            if step != "username":
                # Try one reset if we're not on the username step yet
                if await start_over_btn.count() > 0 and await start_over_btn.is_visible():
                    await start_over_btn.click()
                    ok_btn = self.page.locator("button:has-text('OK')")
                    if await ok_btn.count() > 0:
                        await ok_btn.click()
                    print("[GPS] Reset via Start Over → OK (pre-username).")
                step = await self._authn_type()

            if step == "username":
                user_input = await self._find_username_input()
                await user_input.wait_for(state="visible", timeout=10_000)
                await user_input.fill("")
                await user_input.type(self.sid, delay=20)
                await user_input.dispatch_event("input")
                await user_input.dispatch_event("change")
                await user_input.evaluate("el => el.blur()")

                await self._submit_enclosing_form(user_input)
                print("[GPS] Username submitted.")
                # Confirm transition
                step = await self._authn_type()
                if step != "password":
                    # One more try via direct Go in the same form
                    form = user_input.locator("xpath=ancestor::form[1]")
                    go_btn_user = form.locator("#authn-go-button, button[type='submit'], input[type='submit']").first
                    if await go_btn_user.count() > 0:
                        try:
                            await go_btn_user.click()
                        except Exception:
                            await go_btn_user.click(force=True)
                    step = await self._authn_type()

            # ---------- PASSWORD STEP ----------
            if step == "password":
                pw_input = self.page.locator("#ember534, input[type='password'], input[autocomplete='current-password']").first
                await pw_input.wait_for(state="visible", timeout=10_000)
                await pw_input.fill("")
                await pw_input.type(self.pw, delay=20)
                await pw_input.dispatch_event("input")
                await pw_input.dispatch_event("change")
                await pw_input.evaluate("el => el.blur()")
                await self._debug_dump_state("before_pw_submit")

                await self._submit_enclosing_form(pw_input)
                print("[GPS] Password submit sent.")

                # Hash often moves away from #/authn here
                try:
                    await self.page.wait_for_function(
                        "() => location.hash && location.hash !== '#/authn'",
                        timeout=5_000,
                    )
                    print(f"[GPS] Hash changed → {await self.page.evaluate('() => location.hash')}")
                except PlaywrightTimeoutError:
                    pass

                step = await self._authn_type()

            # ---------- PICTOGRAPH STEP ----------
            if step == "pictograph":
                solved = await self._solve_pictograph()
                print(f"[GPS] Pictograph solved? {solved}")
                step = await self._authn_type()

            # ---------- Finalization / sanity checks ----------
            pictos = self.page.locator(".pictograph-list img.tile-icon").first
            login_form = self.page.locator("form#authn-login-form")
            err = self.page.locator(".error, .cs-error, .validation-error, [role='alert'], .toast-error, .message-error").first

            outcome = "unknown"
            try:
                await pictos.wait_for(state="hidden", timeout=2_000)
                outcome = "pictographs_hidden"
            except PlaywrightTimeoutError:
                try:
                    await login_form.wait_for(state="hidden", timeout=2_000)
                    outcome = "login_form_hidden"
                except PlaywrightTimeoutError:
                    try:
                        await login_form.wait_for(state="detached", timeout=2_000)
                        outcome = "login_form_detached"
                    except PlaywrightTimeoutError:
                        if await err.count() > 0 and await err.first.is_visible():
                            txt = (await err.first.text_content() or "").strip()
                            print(f"[GPS] Error visible: {txt!r}")
                            outcome = "error_visible"

            print(f"[GPS] Post-submit outcome: {outcome} | final step={step!r} | URL: {self.page.url}")
            await self._debug_dump_state(f"final_{outcome}")

        finally:
            try:
                await self.page.context.tracing.stop(path="gps_trace.zip")
                print("[GPS] Trace saved → gps_trace.zip")
            except Exception:
                pass
